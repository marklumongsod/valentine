<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Grand Museum Walk ‚Äî Our Gallery</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #07070b; touch-action: none; }
    canvas { display:block; outline:none; touch-action:none; }

    .hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      color: rgba(255,255,255,.92);
      font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      padding: 10px 10px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      max-width: 92vw;
    }
    .hud b { font-weight: 900; }
    .hint { opacity:.85; margin-top:6px; }

    .overlay {
      position: fixed; inset: 0; z-index: 50;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(900px 460px at 50% 40%, rgba(255,255,255,.10), rgba(0,0,0,.86));
      color: rgba(255,255,255,.95);
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      text-align:center;
      padding: 18px;
    }
    .overlayCard{
      width:min(760px, 92vw);
      background: rgba(0,0,0,.46);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding: 16px 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 24px 70px rgba(0,0,0,.35);
    }
    .overlayCard h1{ margin:0 0 8px; font-size:22px; }
    .overlayCard p{ margin: 8px 0; opacity:.92; }
    .startBtn{
      margin-top: 14px;
      border:none;
      padding: 12px 16px;
      border-radius: 14px;
      background: rgba(255,59,107,.95);
      color: white;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 14px 34px rgba(255,59,107,.22);
      width: 100%;
      max-width: 340px;
    }

    .modal {
      position: fixed; inset: 0; z-index: 60;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.78);
      padding: 14px;
    }
    .modal.show{ display:flex; }
    .modalCard{
      width:min(980px, 96vw);
      background: rgba(10,10,16,.94);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      overflow:hidden;
      box-shadow: 0 30px 90px rgba(0,0,0,.45);
    }
    .modalTop{
      display:flex; align-items:center; justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      color: rgba(255,255,255,.92);
      font: 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .modalTop b{ font-weight: 900; }
    .closeBtn{
      border:none; cursor:pointer;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      font-weight: 900;
    }
    .modalImg{
      width:100%;
      height: min(80vh, 720px);
      object-fit: contain;   /* üî• important */
      display:block;
      background: #000;
    }

    .toast {
      position: fixed; right: 12px; bottom: 12px; z-index: 70;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 14px;
      backdrop-filter: blur(10px);
      font: 12px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity .2s ease, transform .2s ease;
      pointer-events: none;
      white-space: nowrap;
    }
    .toast.show { opacity: 1; transform: translateY(0); }

    /* Touch controls */
    .touchUI { position: fixed; inset: 0; pointer-events: none; z-index: 25; }
    .pad {
      position: absolute;
      bottom: max(14px, env(safe-area-inset-bottom));
      width: 42vw; height: 32vh;
      max-width: 260px; max-height: 220px;
      border-radius: 18px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      pointer-events: auto;
      touch-action: none;
      user-select: none;
    }
    .pad.left { left: max(14px, env(safe-area-inset-left)); }
    .pad.right { right: max(14px, env(safe-area-inset-right)); }
    .padLabel { position:absolute; top:10px; left:12px; color: rgba(255,255,255,.75); font: 12px system-ui; }
    .stick {
      position:absolute; left:50%; top:50%;
      width:64px; height:64px;
      margin-left:-32px; margin-top:-32px;
      border-radius:50%;
      background: rgba(255,255,255,.14);
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      transform: translate(0,0);
    }

    .btnBar {
      position: fixed;
      top: max(12px, env(safe-area-inset-top));
      right: max(12px, env(safe-area-inset-right));
      z-index: 26;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .uiBtn {
      pointer-events:auto;
      border:none;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.92);
      font-weight: 900;
      font: 13px system-ui;
      backdrop-filter: blur(10px);
    }
    .uiBtn.primary { background: rgba(255,59,107,.92); border-color: rgba(255,59,107,.35); }
  </style>
</head>
<body>
  <div class="hud">
    <div><b>Grand Museum Walk</b> ‚Äî plaques + footsteps + auto doors</div>
    <div class="hint">
      Mobile: <b>Left pad</b> move ‚Ä¢ <b>Right pad</b> look ‚Ä¢ Tap <b>VIEW</b> near frame<br/>
      PC: hold <b>WASD</b> ‚Ä¢ <b>Shift</b> sprint ‚Ä¢ Press <b>E</b> near frame
    </div>
  </div>

  <audio id="bgm" preload="auto" loop playsinline>
    <source src="./assets/romantic.mp3" type="audio/mpeg">
  </audio>

  <div class="btnBar">
    <button class="uiBtn primary" id="viewBtn">VIEW FRAME</button>
    <button class="uiBtn" id="runBtn">Auto-run</button>
    <button class="uiBtn" id="muteBtn">Sound: ON</button>
  </div>

  <div class="touchUI">
    <div class="pad left" id="movePad">
      <div class="padLabel">MOVE</div>
      <div class="stick" id="moveStick"></div>
    </div>
    <div class="pad right" id="lookPad">
      <div class="padLabel">LOOK</div>
      <div class="stick" id="lookStick"></div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="overlayCard">
      <h1>Welcome to our museum ‚ú®</h1>
      <p>May sound effects (footsteps + door). Pwede i-mute.</p>
      <p style="opacity:.85">Tip: GitHub Pages works best when your photos are in <b>/assets</b>.</p>
      <button class="startBtn" id="startBtn">START ‚ú®</button>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="modalCard">
      <div class="modalTop">
        <div><b>Gallery View</b></div>
        <button class="closeBtn" id="closeBtn">Close ‚úï</button>
      </div>
      <img class="modalImg" id="modalImg" alt="Selected frame" />
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>

  <script>
    // ==============================
    // 1) YOUR PHOTOS
    // ==============================
    const PHOTO_URLS = [
    "./assets/us1.jpg",
    "./assets/us2.jpg",
    "./assets/us3.jpg",
    "./assets/us4.jpg",
    "./assets/us5.jpg",
    "./assets/us6.jpg",
    "./assets/us7.jpg",
    "./assets/us8.jpg",
    "./assets/us9.jpg",
    "./assets/us10.jpg",
    "./assets/us11.jpg",
    "./assets/us12.jpg",
  ];

    // ==============================
    // 2) PLAQUE TEXTS (match photos)
    // ==============================
    const PLAQUES = [
    { title: "US1 üêæ",  sub: "Ang pinaka-magandang vet sa buong mundo (biased pero totoo)." },
    { title: "US2 ü©∫",  sub: "Love you bebi love hehehe" },
    { title: "US3 üê∂",  sub: "Clinic closed‚Ä¶ pero hindi pa tapos ang gabi natin. üòÇ" },
    { title: "US4 üíâ",  sub: "Tama na injection sa mga hayop, pede ako naman? üòÇ" },
    { title: "US5 üê±",  sub: "Pwede bang after duty‚Ä¶ ako naman? üòÇ" },
    { title: "US6 üêæüíñ", sub: "Kung may award sa Best Vet at Best Girlfriend‚Ä¶ ikaw panalo sa dalawa." },
    { title: "US7 üêï‚Äçü¶∫", sub: "BP ko normal‚Ä¶ pero pag hawak mo, hindi na." },
    { title: "US8 üíì",  sub: "Mas bumibilis heartbeat ko pag naka-scrubs ka." },
    { title: "US9 üê∞",  sub: "Hindi ko kailangan ng kumot‚Ä¶ ikaw lang sapat na. üòÇ" },
    { title: "US10 üê¥", sub: "Kahit pagod ka sa duty, maganda ka pa rin sa paningin ko." },
    { title: "US11 üêæ‚ú®", sub: "Pagod ka sa duty? halika bigyan kita ng yakapsul. üòÇ" },
    { title: "US12 üíï", sub: "Diagnosis ko: mahal na mahal kita, Doc." },
  ];

    // ==============================
    // 3) LOVE WALL (Tagalog humor)
    // ==============================
    const LOVE_TITLE = "HAPPY VALENTINE‚ÄôS, LOVE üíñ";
    const LOVE_LINES = [
      "Alam kong pagod ka minsan sa duty,",
      "pero hindi ka tumitigil magmahal at mag-alaga.",
      "",
      "Nakikita ko kung gaano ka kabuti sa mga hayop,",
      "at lalo kitang minamahal dahil doon.",
      "",
      "Sa bawat buhay na natutulungan mo,",
      "isa ako sa pinaka-swerte dahil ikaw ang kasama ko.",
      "",
      "Happy Valentine‚Äôs, pinakamagaling kong Doktora. üíñ"
    ];

    const overlay = document.getElementById("overlay");
    const startBtn = document.getElementById("startBtn");
    const modal = document.getElementById("modal");
    const modalImg = document.getElementById("modalImg");
    const closeBtn = document.getElementById("closeBtn");
    const toast = document.getElementById("toast");
    const viewBtn = document.getElementById("viewBtn");
    const runBtn = document.getElementById("runBtn");
    const muteBtn = document.getElementById("muteBtn");

    // ========= Background Music (MP3 in /assets) =========
    const bgm = document.getElementById("bgm");
    let musicStarted = false;

    function startMusic() {
      if (!bgm || musicStarted) return;
      musicStarted = true;

      bgm.volume = 0.25; // romantic = soft
      const p = bgm.play();

      // Some browsers return a promise
      if (p && typeof p.catch === "function") {
        p.catch(() => {
          // If it fails (rare after START), user can tap Sound button to trigger play
          showToast("Tap Sound to enable music üéµ");
          musicStarted = false;
        });
      }
    }

    function setMusicMuted(muted){
      if (!bgm) return;
      bgm.muted = muted;
    }


    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.classList.remove("show"), 1100);
    }

    function openModal(url){ modalImg.src = url; modal.classList.add("show"); }
    function closeModal(){ modal.classList.remove("show"); modalImg.src = ""; }
    closeBtn.addEventListener("click", closeModal);
    modal.addEventListener("click", (e)=>{ if(e.target===modal) closeModal(); });

    // ========= Sound (no files; generated with WebAudio) =========
    let audioCtx = null;
    let masterGain = null;
    let soundEnabled = true;

    function ensureAudio(){
      if(audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.55;
      masterGain.connect(audioCtx.destination);
    }

    function setMute(mute){
      soundEnabled = !mute;
      muteBtn.textContent = mute ? "Sound: OFF" : "Sound: ON";
      if(masterGain) masterGain.gain.value = mute ? 0.0 : 0.55;

      // also mute/unmute the background music
      setMusicMuted(mute);

      // if unmuting and music hasn't started yet, try starting it
      if(!mute) startMusic();
    }

    muteBtn.addEventListener("click", ()=>{
      ensureAudio();
      setMute(soundEnabled); // toggle
      showToast(soundEnabled ? "Sound ON üîä" : "Sound OFF üîá");
    });

    // Gentle door whoosh/creak
    function playDoor(){
      if(!soundEnabled) return;
      ensureAudio();
      const t = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(220, t);
      osc.frequency.exponentialRampToValueAtTime(120, t + 0.18);

      const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.12, audioCtx.sampleRate);
      const data = noiseBuf.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);

      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuf;

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.18, t + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.20);

      const filter = audioCtx.createBiquadFilter();
      filter.type="lowpass";
      filter.frequency.setValueAtTime(900, t);
      filter.frequency.exponentialRampToValueAtTime(500, t+0.2);

      osc.connect(gain);
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);

      osc.start(t);
      noise.start(t);
      osc.stop(t+0.22);
      noise.stop(t+0.22);
    }

    // Footstep ‚Äútap‚Äù sound (simple, comfy)
    function playStep(intensity=1){
      if(!soundEnabled) return;
      ensureAudio();
      const t = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.exponentialRampToValueAtTime(70, t + 0.06);

      const gain = audioCtx.createGain();
      const a = 0.06 * Math.min(1.4, intensity);
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.20 * a, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.07);

      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.setValueAtTime(550, t);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);

      osc.start(t);
      osc.stop(t + 0.08);
    }

    // ========= Controls =========
    const pressed = new Set();
    function armKeyboard(){
      window.addEventListener("keydown",(e)=>{
        if(["KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","KeyE","KeyR"].includes(e.code)) e.preventDefault();
        pressed.add(e.code);
      }, {capture:true, passive:false});
      window.addEventListener("keyup",(e)=>{
        if(["KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","KeyE","KeyR"].includes(e.code)) e.preventDefault();
        pressed.delete(e.code);
      }, {capture:true, passive:false});
      window.addEventListener("blur", ()=>pressed.clear());
      document.addEventListener("visibilitychange", ()=>{ if(document.hidden) pressed.clear(); });
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function vecLen(x,y){ return Math.hypot(x,y); }
    function createPad(padEl, stickEl){
      let active=false, id=null, cx=0, cy=0, dx=0, dy=0;
      function reset(){ dx=dy=0; stickEl.style.transform="translate(0px,0px)"; }
      function onDown(e){
        active=true;
        const t = (e.changedTouches ? e.changedTouches[0] : e);
        id = t.identifier ?? "mouse";
        const r = padEl.getBoundingClientRect();
        cx = r.left + r.width/2;
        cy = r.top + r.height/2;
        onMove(e);
      }
      function onMove(e){
        if(!active) return;
        let t=null;
        if(e.changedTouches){
          for(const tt of e.changedTouches){
            if((tt.identifier ?? "mouse")===id){ t=tt; break; }
          }
          if(!t) return;
        } else t=e;

        const r = padEl.getBoundingClientRect();
        const maxR = Math.min(r.width, r.height) * 0.30;
        const x = t.clientX - cx;
        const y = t.clientY - cy;
        const L = vecLen(x,y);
        const nx = (L>maxR) ? (x/L)*maxR : x;
        const ny = (L>maxR) ? (y/L)*maxR : y;

        dx = clamp(nx/maxR, -1, 1);
        dy = clamp(ny/maxR, -1, 1);
        stickEl.style.transform = `translate(${nx}px,${ny}px)`;
      }
      function onUp(e){
        if(!active) return;
        if(e.changedTouches){
          for(const tt of e.changedTouches){
            if((tt.identifier ?? "mouse")===id){ active=false; id=null; reset(); return; }
          }
        } else { active=false; id=null; reset(); }
      }
      padEl.addEventListener("touchstart",(e)=>{ e.preventDefault(); onDown(e); }, {passive:false});
      padEl.addEventListener("touchmove",(e)=>{ e.preventDefault(); onMove(e); }, {passive:false});
      padEl.addEventListener("touchend",(e)=>{ e.preventDefault(); onUp(e); }, {passive:false});
      padEl.addEventListener("touchcancel",(e)=>{ e.preventDefault(); onUp(e); }, {passive:false});
      padEl.addEventListener("mousedown",(e)=>{ e.preventDefault(); onDown(e); }, {passive:false});
      window.addEventListener("mousemove",(e)=>{ onMove(e); }, {passive:true});
      window.addEventListener("mouseup",(e)=>{ onUp(e); }, {passive:true});
      return { get dx(){return dx;}, get dy(){return dy;} };
    }

    function wrapAngleRad(x){
      const pi2 = Math.PI * 2;
      x = (x + Math.PI) % pi2;
      if (x < 0) x += pi2;
      return x - Math.PI;
    }
    function lerpAngle(a,b,t){
      const diff = wrapAngleRad(b - a);
      return a + diff * t;
    }
    function dampAlpha(dt, tau){ return 1 - Math.exp(-dt / Math.max(0.0001, tau)); }

    function makeLoveTexture(){
      const c = document.createElement("canvas");
      c.width=1600; c.height=560;
      const ctx=c.getContext("2d");

      const g=ctx.createLinearGradient(0,0,c.width,c.height);
      g.addColorStop(0,"#ffe6ef");
      g.addColorStop(1,"#ffd2df");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,c.width,c.height);

      ctx.strokeStyle="rgba(199,145,55,0.85)";
      ctx.lineWidth=18;
      ctx.strokeRect(18,18,c.width-36,c.height-36);

      ctx.globalAlpha=0.14;
      ctx.font="90px system-ui";
      for(let i=0;i<16;i++) ctx.fillText("üíñ", 80+i*90, 120+(i%2)*74);
      ctx.globalAlpha=1;

      ctx.fillStyle="#b11c3d";
      ctx.font="900 70px system-ui";
      ctx.textAlign="center";
      ctx.fillText(LOVE_TITLE, c.width/2, 130);

      ctx.fillStyle="#2b1a1f";
      ctx.font="600 30px system-ui";
      let y=180;
      for(const line of LOVE_LINES){ 
        ctx.fillText(line, c.width/2, y); 
        y+=40; 
      }

      return new THREE.CanvasTexture(c);
    }

    let started=false;
    startBtn.addEventListener("click", startFlow);
    startBtn.addEventListener("touchend",(e)=>{ e.preventDefault(); startFlow(); }, {passive:false});

    function startFlow(){
      if(started) return;
      started=true;

      // unlock audio on user gesture
      ensureAudio();
      startMusic();

      if(!window.THREE){ overlay.style.display="none"; alert("Three.js failed to load."); return; }
      overlay.style.display="none";
      armKeyboard();
      initAndRun();
    }

    function initAndRun(){
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x07070b, 16, 120);

      const baseFov=65, runFov=74;
      const camera = new THREE.PerspectiveCamera(baseFov, innerWidth/innerHeight, 0.1, 320);

      const renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setClearColor(0x07070b, 1);
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild(renderer.domElement);

      // Warm + grand lighting
      scene.add(new THREE.HemisphereLight(0xfff3e6, 0x121225, 0.72));
      const sun = new THREE.DirectionalLight(0xfff1df, 0.45);
      sun.position.set(18, 20, 12);
      scene.add(sun);

      function addSpot(x,z){
        const s = new THREE.SpotLight(0xfff0dd, 1.35, 34, Math.PI*0.18, 0.55, 1.05);
        s.position.set(x, 8.2, z);
        s.target.position.set(x, 2.4, z);
        scene.add(s); scene.add(s.target);

        const pool = new THREE.Mesh(
          new THREE.CircleGeometry(2.35, 32),
          new THREE.MeshBasicMaterial({ color: 0xfff3e6, transparent:true, opacity: 0.06 })
        );
        pool.rotation.x = -Math.PI/2;
        pool.position.set(x, 0.012, z);
        scene.add(pool);
      }

      // Layout
      const roomW=30, roomD=18, wallH=6.4, wallT=0.42;
      const roomA_Z=0;
      const hallW=9.5, hallD=10.5;
      const hall_Z=-(roomD/2 + hallD/2);
      const roomB_Z=-(roomD + hallD);

      const colliders = [];

      // Materials
      const wallMat = new THREE.MeshStandardMaterial({ color:0xf6f0f2, roughness:0.96 });
      const trimMat = new THREE.MeshStandardMaterial({ color:0x2a2430, roughness:0.72, metalness:0.06 });
      const goldMat = new THREE.MeshStandardMaterial({ color:0xc79a2e, roughness:0.28, metalness:0.82 });
      const floorMat = new THREE.MeshStandardMaterial({ color:0x16161f, roughness:0.62, metalness:0.12 });

      function addFloor(w,d,z){
        const f = new THREE.Mesh(new THREE.PlaneGeometry(w,d), floorMat);
        f.rotation.x=-Math.PI/2;
        f.position.z=z;
        scene.add(f);

        const strip = new THREE.Mesh(
          new THREE.PlaneGeometry(w*0.55, d*0.98),
          new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity: 0.035 })
        );
        strip.rotation.x = -Math.PI/2;
        strip.position.set(0, 0.011, z);
        scene.add(strip);
      }

      addFloor(roomW, roomD, roomA_Z);
      addFloor(hallW, hallD, hall_Z);
      addFloor(roomW, roomD, roomB_Z);

      const carpet = new THREE.Mesh(
        new THREE.PlaneGeometry(hallW*0.74, hallD*0.96),
        new THREE.MeshStandardMaterial({ color: 0x7a1430, roughness: 0.95, metalness: 0.0 })
      );
      carpet.rotation.x = -Math.PI/2;
      carpet.position.set(0, 0.013, hall_Z);
      scene.add(carpet);

      function addWall(w,h,d,x,y,z){
        const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
        m.position.set(x,y,z);
        scene.add(m);
        colliders.push(m);

        const trim = new THREE.Mesh(new THREE.BoxGeometry(w, 0.18, d+0.02), trimMat);
        trim.position.set(x, 0.09, z);
        scene.add(trim);
      }
      function addCeil(w,d,z){
        const c = new THREE.Mesh(
          new THREE.PlaneGeometry(w,d),
          new THREE.MeshStandardMaterial({ color:0xf9f3f7, roughness:1.0 })
        );
        c.position.set(0, wallH, z);
        c.rotation.x=Math.PI/2;
        scene.add(c);
      }

      // Door opening
      const doorGapW = 3.4;
      const sideW = (roomW - doorGapW)/2;

      // Room A (opening back)
      addWall(roomW, wallH, wallT, 0, wallH/2, roomA_Z + roomD/2);
      addWall(wallT, wallH, roomD, -roomW/2, wallH/2, roomA_Z);
      addWall(wallT, wallH, roomD,  roomW/2, wallH/2, roomA_Z);
      addWall(sideW, wallH, wallT, -(doorGapW/2 + sideW/2), wallH/2, roomA_Z - roomD/2);
      addWall(sideW, wallH, wallT, +(doorGapW/2 + sideW/2), wallH/2, roomA_Z - roomD/2);
      addCeil(roomW, roomD, roomA_Z);

      // Hall
      addWall(hallW, wallH, wallT, 0, wallH/2, hall_Z + hallD/2);
      addWall(hallW, wallH, wallT, 0, wallH/2, hall_Z - hallD/2);
      addWall(wallT, wallH, hallD, -hallW/2, wallH/2, hall_Z);
      addWall(wallT, wallH, hallD,  hallW/2, wallH/2, hall_Z);
      addCeil(hallW, hallD, hall_Z);

      // Room B (opening front)
      addWall(roomW, wallH, wallT, 0, wallH/2, roomB_Z - roomD/2);
      addWall(wallT, wallH, roomD, -roomW/2, wallH/2, roomB_Z);
      addWall(wallT, wallH, roomD,  roomW/2, wallH/2, roomB_Z);
      addWall(sideW, wallH, wallT, -(doorGapW/2 + sideW/2), wallH/2, roomB_Z + roomD/2);
      addWall(sideW, wallH, wallT, +(doorGapW/2 + sideW/2), wallH/2, roomB_Z + roomD/2);
      addCeil(roomW, roomD, roomB_Z);

      // Columns
      const colMat = new THREE.MeshStandardMaterial({ color:0xf4eef1, roughness:0.95 });
      function addColumn(x,z){
        const col = new THREE.Mesh(new THREE.CylinderGeometry(0.23,0.23, wallH, 20), colMat);
        col.position.set(x, wallH/2, z);
        scene.add(col);
        colliders.push(col);
      }
      addColumn(-hallW/2 + 0.7, hall_Z);
      addColumn( hallW/2 - 0.7, hall_Z);

      // Spots
      addSpot(-8, roomA_Z - 5); addSpot(0, roomA_Z - 5); addSpot(8, roomA_Z - 5);
      addSpot(-8, roomA_Z + 5); addSpot(0, roomA_Z + 5); addSpot(8, roomA_Z + 5);
      addSpot(0, hall_Z);
      addSpot(-8, roomB_Z - 5); addSpot(0, roomB_Z - 5); addSpot(8, roomB_Z - 5);
      addSpot(-8, roomB_Z + 5); addSpot(0, roomB_Z + 5); addSpot(8, roomB_Z + 5);

      // Doors
      const doors = [];
      const doorPanels = [];
      const woodMat = new THREE.MeshStandardMaterial({ color: 0x5b3c2f, roughness: 0.78, metalness: 0.05 });
      const frameMat = new THREE.MeshStandardMaterial({ color: 0x1e1a22, roughness: 0.65, metalness: 0.15 });

      function makeDoor({x,z, rotY, swingDir}){
        const g = new THREE.Group();
        g.position.set(x, 0, z);
        g.rotation.y = rotY;

        const width = 2.55, height = 3.85, thickness = 0.16;
        const postW = 0.19, beamH = 0.18, depth = thickness + 0.22;

        const leftPost  = new THREE.Mesh(new THREE.BoxGeometry(postW, height, depth), frameMat);
        const rightPost = new THREE.Mesh(new THREE.BoxGeometry(postW, height, depth), frameMat);
        const topBeam   = new THREE.Mesh(new THREE.BoxGeometry(width + postW*2, beamH, depth), frameMat);

        leftPost.position.set(-width/2 - postW/2, height/2, 0);
        rightPost.position.set(width/2 + postW/2, height/2, 0);
        topBeam.position.set(0, height + beamH/2, 0);
        g.add(leftPost, rightPost, topBeam);

        const hinge = new THREE.Group();
        hinge.position.set(-width/2, 0, 0);
        g.add(hinge);

        const panel = new THREE.Mesh(new THREE.BoxGeometry(width, height, thickness), woodMat);
        panel.position.set(width/2, height/2, 0);
        hinge.add(panel);

        const handle = new THREE.Mesh(new THREE.SphereGeometry(0.08, 18, 18), goldMat);
        handle.position.set(width*0.83, height*0.55, thickness/2 + 0.05);
        hinge.add(handle);

        const collider = new THREE.Mesh(
          new THREE.BoxGeometry(width, height, thickness + 0.20),
          new THREE.MeshBasicMaterial({ transparent:true, opacity:0 })
        );
        collider.position.copy(panel.position);
        hinge.add(collider);

        scene.add(g);
        const obj = { group:g, hinge, collider, openT:0, swingDir, wasOpen:false };
        doors.push(obj);
        doorPanels.push(collider);
        return obj;
      }

      const door1Z = roomA_Z - roomD/2 + 0.12;
      const door2Z = roomB_Z + roomD/2 - 0.12;
      makeDoor({ x:0, z:door1Z, rotY:0,       swingDir:+1 });
      makeDoor({ x:0, z:door2Z, rotY:Math.PI, swingDir:+1 });

      // Character (girl)
      const player = new THREE.Group();
      scene.add(player);

      const skin  = new THREE.MeshStandardMaterial({ color:0xffd4c2, roughness:0.85 });
      const hair  = new THREE.MeshStandardMaterial({ color:0x24140f, roughness:0.9 });
      const dress = new THREE.MeshStandardMaterial({ color:0xff3b6b, roughness:0.7 });
      const shoe  = new THREE.MeshStandardMaterial({ color:0x202026, roughness:0.6 });

      const head = new THREE.Mesh(new THREE.SphereGeometry(0.36, 24, 24), skin);
      head.position.set(0, 1.60, 0); player.add(head);

      const hairCap = new THREE.Mesh(new THREE.SphereGeometry(0.38, 24, 24, 0, Math.PI*2, 0, Math.PI*0.65), hair);
      hairCap.position.copy(head.position); hairCap.position.y += 0.05; player.add(hairCap);

      const pony = new THREE.Mesh(new THREE.SphereGeometry(0.21, 20, 20), hair);
      pony.position.set(0.24, 1.46, -0.20); player.add(pony);

      const body = new THREE.Mesh(new THREE.CylinderGeometry(0.44, 0.58, 0.95, 18), dress);
      body.position.set(0, 1.00, 0); player.add(body);

      const armGeo = new THREE.CapsuleGeometry(0.11, 0.44, 6, 10);
      const la = new THREE.Mesh(armGeo, skin); la.position.set(-0.58, 1.10, 0); player.add(la);
      const ra = new THREE.Mesh(armGeo, skin); ra.position.set(0.58, 1.10, 0); player.add(ra);

      const legGeo = new THREE.CapsuleGeometry(0.12, 0.52, 6, 10);
      const ll = new THREE.Mesh(legGeo, skin); ll.position.set(-0.19, 0.38, 0); player.add(ll);
      const rl = new THREE.Mesh(legGeo, skin); rl.position.set(0.19, 0.38, 0); player.add(rl);

      const shoeGeo = new THREE.BoxGeometry(0.24, 0.10, 0.34);
      const ls = new THREE.Mesh(shoeGeo, shoe); ls.position.set(-0.19, 0.06, 0.08); player.add(ls);
      const rs = new THREE.Mesh(shoeGeo, shoe); rs.position.set(0.19, 0.06, 0.08); player.add(rs);

      player.position.set(0, 0, roomA_Z + 4);

      // Love wall
      const loveTex = makeLoveTexture();
      const loveWall = new THREE.Mesh(
        new THREE.PlaneGeometry(10.4, 3.9),
        new THREE.MeshStandardMaterial({ map: loveTex, roughness: 0.95 })
      );
      loveWall.position.set(0, 3.18, roomB_Z - roomD/2 + 0.60);
      scene.add(loveWall);

      // Frames + Plaques
      const loader = new THREE.TextureLoader();
      loader.crossOrigin = "anonymous";
      const framePlanes = [];

      function drawWrappedText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(" ");
      let line = "";
      let lines = [];
    
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + " ";
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
    
        if (testWidth > maxWidth && n > 0) {
          lines.push(line);
          line = words[n] + " ";
        } else {
          line = testLine;
        }
      }
      lines.push(line);
    
      lines.forEach((l, i) => {
        ctx.fillText(l.trim(), x, y + (i * lineHeight));
      });
    }
    
          
      function makePlaqueTexture(title, sub){
        const c = document.createElement("canvas");
        c.width = 900; c.height = 240;
        const ctx = c.getContext("2d");

        // plaque background
        ctx.fillStyle = "rgba(16,14,18,0.92)";
        ctx.fillRect(0,0,c.width,c.height);

        // gold border
        ctx.strokeStyle = "rgba(199,154,46,0.85)";
        ctx.lineWidth = 10;
        ctx.strokeRect(10,10,c.width-20,c.height-20);

        const TITLE_SIZE = 42;
        const SUB_SIZE = 28;
        
        ctx.textAlign = "center";
        
        // TITLE
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.font = `900 ${TITLE_SIZE}px system-ui`;
        drawWrappedText(ctx, title, c.width/2, 80, 750, 50);
        
        // SUBTEXT
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.font = `600 ${SUB_SIZE}px system-ui`;
        drawWrappedText(ctx, sub, c.width/2, 140, 750, 38);


        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.font = "700 28px system-ui";
        ctx.fillText("Tap VIEW / Press E to view frame", c.width/2, 205);

        const tex = new THREE.CanvasTexture(c);
        tex.needsUpdate = true;
        return tex;
      }

      function makeFrame(texture, x,y,z, rotY, url, plaque){
        const g = new THREE.Group();
        g.position.set(x,y,z);
        g.rotation.y = rotY;

        const outer = new THREE.Mesh(new THREE.BoxGeometry(2.85,1.95,0.10), goldMat);
        outer.position.z = 0.02; g.add(outer);

        const inner = new THREE.Mesh(
          new THREE.BoxGeometry(2.60,1.72,0.06),
          new THREE.MeshStandardMaterial({ color:0x1b151a, roughness:0.6, metalness:0.1 })
        );
        inner.position.z = 0.06; g.add(inner);

        const matte = new THREE.Mesh(
          new THREE.BoxGeometry(2.35,1.48,0.02),
          new THREE.MeshStandardMaterial({ color:0xf7f0f4, roughness:1.0 })
        );
        matte.position.z = 0.085; g.add(matte);

        const photo = new THREE.Mesh(
          new THREE.PlaneGeometry(2.10,1.22),
          new THREE.MeshStandardMaterial({ map: texture, roughness:0.9 })
        );
        photo.position.z = 0.10;
        photo.userData.photoUrl = url;
        framePlanes.push(photo);
        g.add(photo);

        // plaque under frame
        const pTex = makePlaqueTexture(plaque.title, plaque.sub);
        const plaqueMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(2.95, 0.78),
          new THREE.MeshStandardMaterial({ map: pTex, roughness: 0.95 })
        );
        plaqueMesh.position.set(0, -1.30, 0.11);
        g.add(plaqueMesh);

        scene.add(g);
      }

      function placeFrames(zCenter, offset){
        const frameY=3.2;
        const backZ=zCenter-roomD/2+0.40, frontZ=zCenter+roomD/2-0.40;
        const leftX=-roomW/2+0.40, rightX=roomW/2-0.40;

        const ps = [
          {x:-8,y:frameY,z:backZ, rotY:0},
          {x: 0,y:frameY,z:backZ, rotY:0},
          {x: 8,y:frameY,z:backZ, rotY:0},
          {x:-8,y:frameY,z:frontZ,rotY:Math.PI},
          {x: 0,y:frameY,z:frontZ,rotY:Math.PI},
          {x: 8,y:frameY,z:frontZ,rotY:Math.PI},
          {x:leftX, y:frameY,z:zCenter-5, rotY: Math.PI/2},
          {x:leftX, y:frameY,z:zCenter+5, rotY: Math.PI/2},
          {x:rightX,y:frameY,z:zCenter-5, rotY:-Math.PI/2},
          {x:rightX,y:frameY,z:zCenter+5, rotY:-Math.PI/2},
        ];

        ps.forEach((p,i)=>{
          const url = PHOTO_URLS[(offset+i)%PHOTO_URLS.length];
          const plaque = PLAQUES[(offset+i)%PLAQUES.length] || {title:"Our Moment", sub:"Ikaw pa rin."};
          loader.load(url, (tex)=>makeFrame(tex,p.x,p.y,p.z,p.rotY,url,plaque));
        });
      }
      placeFrames(roomA_Z, 0);
      placeFrames(roomB_Z, 2);

      function nearestFrame(maxDist=2.9){
        let best=null, bestD=Infinity;
        const p = new THREE.Vector3(player.position.x, 1.35, player.position.z);
        for(const pl of framePlanes){
          const wp=new THREE.Vector3(); pl.getWorldPosition(wp);
          const d=wp.distanceTo(p);
          if(d < bestD && d <= maxDist){ bestD=d; best=pl; }
        }
        return best;
      }

      function viewNearest(){
        if(modal.classList.contains("show")) return;
        const f = nearestFrame(2.9);
        if(f?.userData?.photoUrl) openModal(f.userData.photoUrl);
        else showToast("Lapitan mo yung frame üñºÔ∏è");
      }
      viewBtn.addEventListener("click", viewNearest);

      // Pads
      const movePad = createPad(document.getElementById("movePad"), document.getElementById("moveStick"));
      const lookPad = createPad(document.getElementById("lookPad"), document.getElementById("lookStick"));

      // Camera
      let yaw=Math.PI, pitch=0.30, dist=11.5;
      const minDist=5.5, maxDist=18, minPitch=0.08, maxPitch=1.05;
      const LOOK_SENS=2.35;

      // zoom
      let pinchActive=false, pinchStart=0, pinchDist=0;
      function touchDist(t1,t2){ const dx=t1.clientX-t2.clientX, dy=t1.clientY-t2.clientY; return Math.hypot(dx,dy); }
      window.addEventListener("touchstart",(e)=>{
        if(e.touches && e.touches.length===2){
          pinchActive=true;
          pinchDist = touchDist(e.touches[0], e.touches[1]);
          pinchStart = dist;
        }
      }, {passive:true});
      window.addEventListener("touchmove",(e)=>{
        if(pinchActive && e.touches && e.touches.length===2){
          const d0 = touchDist(e.touches[0], e.touches[1]);
          const delta = (pinchDist - d0) * 0.02;
          dist = clamp(pinchStart + delta, minDist, maxDist);
        }
      }, {passive:true});
      window.addEventListener("touchend",(e)=>{ if(!e.touches || e.touches.length<2) pinchActive=false; }, {passive:true});
      window.addEventListener("wheel",(e)=>{
        dist += e.deltaY*0.0036;
        dist = clamp(dist, minDist, maxDist);
      }, {passive:true});

      // Movement
      const vel=new THREE.Vector3(), targetVel=new THREE.Vector3(), tmpF=new THREE.Vector3(), tmpR=new THREE.Vector3(), wish=new THREE.Vector3();
      const WALK=10.8, RUN=17.2, ACC=0.05, BRK=0.06, ROT=22.0;
      let walkPhase=0;

      let autoRun=false;
      runBtn.addEventListener("click", ()=>{
        autoRun=!autoRun;
        runBtn.textContent = autoRun ? "Auto-run ‚úì" : "Auto-run";
        showToast(autoRun ? "Auto-run ON ‚úÖ" : "Auto-run OFF ‚ùé");
      });

      const bounds = {
        xMin: -roomW/2 + 1.3,
        xMax:  roomW/2 - 1.3,
        zMin: roomB_Z - roomD/2 + 1.3,
        zMax: roomA_Z + roomD/2 - 1.3
      };

      // Doors
      function updateDoors(dt){
        const p = new THREE.Vector3(player.position.x, 1.35, player.position.z);
        for(const d of doors){
          const wp = new THREE.Vector3(); d.group.getWorldPosition(wp);
          const distTo = wp.distanceTo(p);
          const wantOpen = distTo < 2.8;
          const target = wantOpen ? 1 : 0;

          d.openT += (target - d.openT) * (1 - Math.exp(-10 * dt));
          const openAngle = 1.35;
          d.hinge.rotation.y = d.swingDir * openAngle * d.openT;
          d.collider.userData.blocking = (d.openT < 0.35);

          // sound trigger on state change
          const isOpenNow = d.openT > 0.65;
          if(isOpenNow && !d.wasOpen){ playDoor(); }
          d.wasOpen = isOpenNow;
        }
      }

      function applyDoorBlocking(){
        for(const d of doors){
          if(!d.collider.userData.blocking) continue;
          const wp = new THREE.Vector3(); d.group.getWorldPosition(wp);
          const doorNormal = new THREE.Vector3(0,0,1).applyQuaternion(d.group.quaternion);

          const p = new THREE.Vector3(player.position.x, 1.35, player.position.z);
          const toP = p.clone().sub(new THREE.Vector3(wp.x, 1.35, wp.z));
          const distAlong = toP.dot(doorNormal);
          const lateral = toP.clone().sub(doorNormal.clone().multiplyScalar(distAlong));
          const lateralLen = lateral.length();

          const halfW = 1.55;
          if(lateralLen < halfW && Math.abs(distAlong) < 0.24){
            const push = (0.24 - Math.abs(distAlong)) + 0.01;
            const dir = distAlong >= 0 ? 1 : -1;
            player.position.x += doorNormal.x * push * dir;
            player.position.z += doorNormal.z * push * dir;
          }
        }
      }

      // Camera collision
      const camTarget=new THREE.Vector3(), desiredCam=new THREE.Vector3(), finalCam=new THREE.Vector3();
      const raycaster=new THREE.Raycaster(), camDir=new THREE.Vector3();
      const camSafety=0.38, camUpOffset=1.05;

      function applyCamCollision(target, desiredPos){
        camDir.copy(desiredPos).sub(target);
        const L = camDir.length();
        if(L < 0.001) return desiredPos;
        camDir.normalize();
        raycaster.set(target, camDir);
        raycaster.far = L;

        const all = colliders.concat(doorPanels);
        const hits = raycaster.intersectObjects(all,false);
        if(hits.length){
          const hitDist = Math.max(0.85, hits[0].distance - camSafety);
          return finalCam.copy(target).addScaledVector(camDir, hitDist);
        }
        return desiredPos;
      }

      // Initial camera
      camTarget.set(player.position.x, 1.35, player.position.z);
      camera.position.set(camTarget.x, camTarget.y + 6, camTarget.z + 12);
      camera.lookAt(camTarget);
      renderer.render(scene, camera);

      // Footstep scheduler
      let stepClock = 0;
      function stepInterval(speedRatio){
        // faster when running
        return 0.50 - 0.22 * clamp(speedRatio, 0, 1); // ~0.5s walk, ~0.28s run
      }

      // Loop
      const clock = new THREE.Clock();
      function loop(){
        const dt = Math.min(clock.getDelta(), 0.033);

        // Look
        yaw   -= lookPad.dx * LOOK_SENS * dt;
        pitch -= lookPad.dy * (LOOK_SENS * 0.8) * dt;
        pitch = clamp(pitch, minPitch, maxPitch);

        // basis
        tmpF.set(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        tmpF.y=0; tmpF.normalize();
        tmpR.copy(tmpF).cross(new THREE.Vector3(0,1,0)).normalize();

        const kw = pressed.has("KeyW"), ka = pressed.has("KeyA"), ks = pressed.has("KeyS"), kd = pressed.has("KeyD");
        const shift = pressed.has("ShiftLeft") || pressed.has("ShiftRight");
        const kView = pressed.has("KeyE");
        const kAuto = pressed.has("KeyR");

        if(kAuto && !loop._rLatch){
          loop._rLatch=true;
          autoRun=!autoRun;
          runBtn.textContent = autoRun ? "Auto-run ‚úì" : "Auto-run";
          showToast(autoRun ? "Auto-run ON ‚úÖ" : "Auto-run OFF ‚ùé");
        }
        if(!kAuto) loop._rLatch=false;

        if(kView && !loop._eLatch){
          loop._eLatch=true;
          viewNearest();
        }
        if(!kView) loop._eLatch=false;

        // Wish
        wish.set(0,0,0);
        const padForward = -movePad.dy;
        const padRight   =  movePad.dx;
        wish.addScaledVector(tmpF, padForward);
        wish.addScaledVector(tmpR, padRight);

        if(autoRun) wish.add(tmpF);
        if(kw) wish.add(tmpF);
        if(ks) wish.sub(tmpF);
        if(kd) wish.add(tmpR);
        if(ka) wish.sub(tmpR);

        const hasInput = (wish.lengthSq()>0) && !modal.classList.contains("show");
        const top = (shift && hasInput) ? 17.2 : 10.8;

        // fov
        const desiredFov = ((shift) && hasInput) ? 74 : 65;
        camera.fov = camera.fov + (desiredFov - camera.fov) * (1 - Math.exp(-10*dt));
        camera.updateProjectionMatrix();

        if(hasInput){
          wish.normalize();
          targetVel.copy(wish).multiplyScalar(top);
          vel.lerp(targetVel, dampAlpha(dt, 0.05));

          const targetYaw = Math.atan2(wish.x, wish.z);
          player.rotation.y = lerpAngle(player.rotation.y, targetYaw, 1 - Math.exp(-22*dt));

          const sp = Math.hypot(vel.x, vel.z);
          walkPhase += dt*(sp*1.05);

          // footsteps
          const speedRatio = clamp(sp / 17.2, 0, 1);
          stepClock -= dt;
          if(stepClock <= 0){
            playStep(0.9 + speedRatio*0.9);
            stepClock = stepInterval(speedRatio);
          }
        } else {
          targetVel.set(0,0,0);
          vel.lerp(targetVel, dampAlpha(dt, 0.06));
          stepClock = 0; // reset so it doesn't "keep stepping"
        }

        // bob
        const sp2 = Math.hypot(vel.x, vel.z);
        const speedFactor = Math.min(1, sp2/17.2);
        player.position.y = (Math.abs(Math.sin(walkPhase))*0.03)*speedFactor;

        if(!modal.classList.contains("show")){
          player.position.x += vel.x*dt;
          player.position.z += vel.z*dt;
        }

        player.position.x = THREE.MathUtils.clamp(player.position.x, bounds.xMin, bounds.xMax);
        player.position.z = THREE.MathUtils.clamp(player.position.z, bounds.zMin, bounds.zMax);

        updateDoors(dt);
        applyDoorBlocking();

        // Camera follow
        camTarget.set(player.position.x, 1.35 + player.position.y, player.position.z);
        const cosP=Math.cos(pitch), sinP=Math.sin(pitch);
        desiredCam.set(
          camTarget.x + Math.sin(yaw)*(dist*cosP),
          camTarget.y + (dist*sinP) + 1.05,
          camTarget.z + Math.cos(yaw)*(dist*cosP)
        );

        const camPos = applyCamCollision(camTarget, desiredCam);
        camera.position.lerp(camPos, 1 - Math.exp(-10.5*dt));
        camera.lookAt(camTarget);

        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      window.addEventListener("resize", ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      showToast("Walk near doors ‚Äî they open automatically üö™‚ú®");
    }
  </script>
</body>
</html>













