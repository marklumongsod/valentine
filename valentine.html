<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Museum Walk â€” CDN (No Localhost)</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0b10; }
    canvas { display:block; outline:none; }

    .hud {
      position: fixed; left: 14px; top: 14px; z-index: 10;
      color: rgba(255,255,255,.92);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      padding: 12px 12px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      max-width: 860px;
    }
    .hud b { font-weight: 900; }
    .hint { opacity:.85; margin-top:6px; }

    .overlay {
      position: fixed; inset: 0; z-index: 50;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(900px 460px at 50% 40%, rgba(255,255,255,.08), rgba(0,0,0,.82));
      color: rgba(255,255,255,.95);
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      text-align:center;
      padding: 24px;
    }
    .overlayCard{
      width:min(760px, 92vw);
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding: 18px 18px;
      backdrop-filter: blur(10px);
      box-shadow: 0 24px 70px rgba(0,0,0,.35);
    }
    .overlayCard h1{ margin:0 0 10px; font-size:22px; }
    .overlayCard p{ margin: 8px 0; opacity:.92; }
    .startBtn{
      margin-top: 14px;
      border:none;
      padding: 12px 16px;
      border-radius: 14px;
      background: rgba(255,59,107,.95);
      color: white;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 14px 34px rgba(255,59,107,.22);
    }

    .modal {
      position: fixed; inset: 0; z-index: 60;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.75);
      padding: 18px;
    }
    .modal.show{ display:flex; }
    .modalCard{
      width:min(980px, 96vw);
      background: rgba(10,10,16,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      overflow:hidden;
      box-shadow: 0 30px 90px rgba(0,0,0,.45);
    }
    .modalTop{
      display:flex; align-items:center; justify-content:space-between;
      gap: 12px;
      padding: 12px 14px;
      color: rgba(255,255,255,.92);
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .modalTop b{ font-weight: 900; }
    .closeBtn{
      border:none; cursor:pointer;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      font-weight: 900;
    }
    .modalImg{
      width:100%;
      height: min(70vh, 680px);
      object-fit: cover;
      display:block;
    }

    .toast {
      position: fixed; right: 14px; bottom: 14px; z-index: 70;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 14px;
      backdrop-filter: blur(10px);
      font: 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity .2s ease, transform .2s ease;
      pointer-events: none;
      white-space: nowrap;
    }
    .toast.show { opacity: 1; transform: translateY(0); }

    .errorBox {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);
      z-index: 999;
      display:none;
      width: min(980px, 92vw);
      background: rgba(0,0,0,.75);
      border: 1px solid rgba(255,80,120,.45);
      color: rgba(255,255,255,.95);
      padding: 14px 16px;
      border-radius: 16px;
      font: 13px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      backdrop-filter: blur(10px);
    }
    .errorBox.show { display:block; }
    .errorBox b { color: #ff547a; }
  </style>
</head>
<body>
  <div class="hud">
    <div><b>Museum Walk</b> â€” hold WASD + Roblox-ish camera</div>
    <div class="hint">
      Move: <b>Hold W A S D</b> â€¢ Sprint: <b>Shift</b> â€¢ Auto-run toggle: <b>R</b><br/>
      Camera: <b>Hold LMB</b> drag â€¢ Zoom: <b>Scroll</b> â€¢ Roblox mouse-lock: <b>Hold RMB</b><br/>
      View frame: <b>E</b> near a photo
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="overlayCard">
      <h1>Click START to enter the museum</h1>
      <p>CDN mode âœ… (works even if you open the HTML directly)</p>
      <p style="font-size:13px;opacity:.85">
        Needs internet (for Three.js + photos). If you want fully offline, we can embed everything.
      </p>
      <button class="startBtn" id="startBtn">START âœ¨</button>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="modalCard">
      <div class="modalTop">
        <div><b>Gallery View</b> â€” Press <b>Esc</b> to close</div>
        <button class="closeBtn" id="closeBtn">Close âœ•</button>
      </div>
      <img class="modalImg" id="modalImg" alt="Selected frame" />
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="errorBox" id="errorBox"></div>

  <!-- âœ… CDN (NON-MODULE) â€” pinned to r149 to avoid the r150+ deprecation warning -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>

  <script>
    // ============================================================
    // âœ… PUT YOUR PHOTOS HERE (use direct image URLs)
    // ============================================================
    const PHOTO_URLS = [
      // Replace with your own (public) image URLs:
      // "https://your-site.com/us1.jpg",
      // "https://your-site.com/us2.jpg",
      // "https://your-site.com/us3.jpg",
      // "https://your-site.com/us4.jpg",

      // placeholders:
      "https://images.unsplash.com/photo-1518199266791-5375a83190b7?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1518621736915-f3b1c41bfd00?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1519681393784-d120267933ba?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1517486808906-6ca8b3f04846?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1529626455594-4ff0802cfb7e?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1524504388940-b1c1722653e1?w=1400&h=900&fit=crop",
    ];

    // ============================================================
    // âœ… TAGALOG FUNNY VALENTINE WALL
    // ============================================================
    const LOVE_TITLE = "HAPPY VALENTINEâ€™S, LOVE ðŸ’–";
    const LOVE_LINES = [
      "Ikaw ang paborito kong notificationâ€¦",
      "kahit naka-silent ang phone.",
      "",
      "Mas mahal kita kaysa sa",
      "â€œgit pushâ€ na walang conflicts ðŸ˜­",
      "",
      "P.S. Auto-run ON para saâ€™yo ðŸƒâ€â™€ï¸ðŸ’˜"
    ];

    const overlay = document.getElementById("overlay");
    const startBtn = document.getElementById("startBtn");
    const modal = document.getElementById("modal");
    const modalImg = document.getElementById("modalImg");
    const closeBtn = document.getElementById("closeBtn");
    const toast = document.getElementById("toast");
    const errorBox = document.getElementById("errorBox");

    function showToast(msg) {
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.classList.remove("show"), 1500);
    }
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }
    function showError(msg) {
      errorBox.innerHTML = `<b>ERROR:</b> ${escapeHtml(msg)}`;
      errorBox.classList.add("show");
    }

    function openModal(url){ modalImg.src = url; modal.classList.add("show"); }
    function closeModal(){ modal.classList.remove("show"); modalImg.src = ""; }
    closeBtn.addEventListener("click", closeModal);
    modal.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });
    window.addEventListener("keydown", (e) => { if (e.code === "Escape") closeModal(); }, true);

    // Hold input
    const pressed = new Set();
    function armInput() {
      window.addEventListener("keydown", (e) => {
        if (["KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","KeyE","KeyR"].includes(e.code)) e.preventDefault();
        pressed.add(e.code);
      }, { capture:true, passive:false });

      window.addEventListener("keyup", (e) => {
        if (["KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","KeyE","KeyR"].includes(e.code)) e.preventDefault();
        pressed.delete(e.code);
      }, { capture:true, passive:false });

      window.addEventListener("blur", () => pressed.clear());
      document.addEventListener("visibilitychange", () => { if (document.hidden) pressed.clear(); });
    }

    // Wrap-safe angle lerp (no THREE.MathUtils extras needed)
    function wrapAngleRad(x) {
      const pi2 = Math.PI * 2;
      x = (x + Math.PI) % pi2;
      if (x < 0) x += pi2;
      return x - Math.PI;
    }
    function lerpAngle(a, b, t) {
      const diff = wrapAngleRad(b - a);
      return a + diff * t;
    }
    function dampAlpha(dt, tau) { return 1 - Math.exp(-dt / Math.max(0.0001, tau)); }

    // Error catcher (avoids silent black screen)
    window.addEventListener("error", (e) => showError(e.message || e.error || "Unknown error"));
    window.addEventListener("unhandledrejection", (e) => showError(e.reason || "Unhandled promise rejection"));

    let started = false;
    startBtn.addEventListener("click", () => {
      if (started) return;
      started = true;

      if (!window.THREE) {
        overlay.style.display = "none";
        showError("THREE is undefined. CDN failed to load (no internet / blocked CDN).");
        return;
      }

      overlay.style.display = "none";
      armInput();

      try { initAndRun(); }
      catch (err) { showError(err?.stack || err?.message || String(err)); }
    });

    function makeLoveTexture() {
      const c = document.createElement("canvas");
      c.width = 1400; c.height = 520;
      const ctx = c.getContext("2d");

      const g = ctx.createLinearGradient(0,0,c.width,c.height);
      g.addColorStop(0, "#ffe1ec");
      g.addColorStop(1, "#ffd0de");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,c.width,c.height);

      ctx.strokeStyle = "rgba(255,59,107,0.75)";
      ctx.lineWidth = 16;
      ctx.strokeRect(16,16,c.width-32,c.height-32);

      ctx.globalAlpha = 0.12;
      ctx.font = "80px system-ui";
      for (let i=0;i<14;i++) ctx.fillText("ðŸ’–", 80 + i*90, 110 + (i%2)*70);
      ctx.globalAlpha = 1;

      ctx.fillStyle = "#ff2f67";
      ctx.font = "900 64px system-ui";
      ctx.textAlign = "center";
      ctx.fillText(LOVE_TITLE, c.width/2, 120);

      ctx.fillStyle = "#2b1a1f";
      ctx.font = "600 44px system-ui";
      let y = 200;
      for (const line of LOVE_LINES) { ctx.fillText(line, c.width/2, y); y += 54; }

      const tex = new THREE.CanvasTexture(c);
      return tex;
    }

    function initAndRun() {
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0b0b10, 22, 90);

      const baseFov = 65, runFov = 74;
      const camera = new THREE.PerspectiveCamera(baseFov, innerWidth / innerHeight, 0.1, 220);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setClearColor(0x0b0b10, 1);
      document.body.appendChild(renderer.domElement);

      renderer.domElement.tabIndex = 0;
      renderer.domElement.focus();
      renderer.domElement.addEventListener("pointerdown", () => renderer.domElement.focus());
      renderer.domElement.oncontextmenu = (e) => e.preventDefault();

      scene.add(new THREE.HemisphereLight(0xffffff, 0x1b1b2a, 0.9));
      const key = new THREE.DirectionalLight(0xffffff, 0.9);
      key.position.set(10, 16, 10);
      scene.add(key);

      function addSpot(x, z) {
        const s = new THREE.SpotLight(0xffffff, 1.0, 28, Math.PI * 0.22, 0.55, 1.2);
        s.position.set(x, 7.6, z);
        s.target.position.set(x, 2.0, z);
        scene.add(s);
        scene.add(s.target);
      }

      // Rooms
      const roomW = 28, roomD = 16, wallH = 6, wallT = 0.4;
      const roomA_Z = 0;
      const hallW = 8, hallD = 10;
      const hall_Z = -(roomD/2 + hallD/2);
      const roomB_Z = -(roomD + hallD);

      const colliders = [];

      function addFloor(w, d, zCenter) {
        const f = new THREE.Mesh(
          new THREE.PlaneGeometry(w, d),
          new THREE.MeshStandardMaterial({ color: 0x1a1a22, roughness: 0.88, metalness: 0.05 })
        );
        f.rotation.x = -Math.PI / 2;
        f.position.z = zCenter;
        scene.add(f);
      }
      addFloor(roomW, roomD, roomA_Z);
      addFloor(hallW, hallD, hall_Z);
      addFloor(roomW, roomD, roomB_Z);

      const wallMat = new THREE.MeshStandardMaterial({ color: 0xf3eef2, roughness: 0.96 });

      function addWall(w, h, d, x, y, z) {
        const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
        m.position.set(x, y, z);
        scene.add(m);
        colliders.push(m);
      }
      function addCeil(w, d, zCenter) {
        const c = new THREE.Mesh(
          new THREE.PlaneGeometry(w, d),
          new THREE.MeshStandardMaterial({ color: 0xf7f1f6, roughness: 1.0 })
        );
        c.position.set(0, wallH, zCenter);
        c.rotation.x = Math.PI / 2;
        scene.add(c);
      }

      const doorW = hallW;
      const sideW = (roomW - doorW) / 2;

      // Room A (door at back)
      addWall(roomW, wallH, wallT, 0, wallH/2, roomA_Z + roomD/2);
      addWall(wallT, wallH, roomD, -roomW/2, wallH/2, roomA_Z);
      addWall(wallT, wallH, roomD,  roomW/2, wallH/2, roomA_Z);
      addWall(sideW, wallH, wallT, -(doorW/2 + sideW/2), wallH/2, roomA_Z - roomD/2);
      addWall(sideW, wallH, wallT, +(doorW/2 + sideW/2), wallH/2, roomA_Z - roomD/2);
      addCeil(roomW, roomD, roomA_Z);

      // Hall
      addWall(hallW, wallH, wallT, 0, wallH/2, hall_Z + hallD/2);
      addWall(hallW, wallH, wallT, 0, wallH/2, hall_Z - hallD/2);
      addWall(wallT, wallH, hallD, -hallW/2, wallH/2, hall_Z);
      addWall(wallT, wallH, hallD,  hallW/2, wallH/2, hall_Z);
      addCeil(hallW, hallD, hall_Z);

      // Room B (door at front)
      addWall(roomW, wallH, wallT, 0, wallH/2, roomB_Z - roomD/2);
      addWall(wallT, wallH, roomD, -roomW/2, wallH/2, roomB_Z);
      addWall(wallT, wallH, roomD,  roomW/2, wallH/2, roomB_Z);
      addWall(sideW, wallH, wallT, -(doorW/2 + sideW/2), wallH/2, roomB_Z + roomD/2);
      addWall(sideW, wallH, wallT, +(doorW/2 + sideW/2), wallH/2, roomB_Z + roomD/2);
      addCeil(roomW, roomD, roomB_Z);

      // Lights
      addSpot(-7, roomA_Z - 4); addSpot(0, roomA_Z - 4); addSpot(7, roomA_Z - 4);
      addSpot(-7, roomA_Z + 4); addSpot(0, roomA_Z + 4); addSpot(7, roomA_Z + 4);
      addSpot(0, hall_Z);
      addSpot(-7, roomB_Z - 4); addSpot(0, roomB_Z - 4); addSpot(7, roomB_Z - 4);
      addSpot(-7, roomB_Z + 4); addSpot(0, roomB_Z + 4); addSpot(7, roomB_Z + 4);

      // Girl character
      const player = new THREE.Group();
      scene.add(player);

      const skinMat  = new THREE.MeshStandardMaterial({ color: 0xffd4c2, roughness: 0.85 });
      const hairMat  = new THREE.MeshStandardMaterial({ color: 0x24140f, roughness: 0.9 });
      const dressMat = new THREE.MeshStandardMaterial({ color: 0xff3b6b, roughness: 0.7 });
      const shoeMat  = new THREE.MeshStandardMaterial({ color: 0x22222a, roughness: 0.6 });

      const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 24, 24), skinMat);
      head.position.set(0, 1.55, 0); player.add(head);

      const hairCap = new THREE.Mesh(new THREE.SphereGeometry(0.37, 24, 24, 0, Math.PI*2, 0, Math.PI*0.65), hairMat);
      hairCap.position.copy(head.position); hairCap.position.y += 0.05; player.add(hairCap);

      const pony = new THREE.Mesh(new THREE.SphereGeometry(0.20, 20, 20), hairMat);
      pony.position.set(0.22, 1.42, -0.18); player.add(pony);

      const dress = new THREE.Mesh(new THREE.CylinderGeometry(0.42, 0.55, 0.9, 18), dressMat);
      dress.position.set(0, 0.95, 0); player.add(dress);

      const armGeo = new THREE.CapsuleGeometry(0.11, 0.42, 6, 10);
      const leftArm = new THREE.Mesh(armGeo, skinMat); leftArm.position.set(-0.55, 1.05, 0); player.add(leftArm);
      const rightArm = new THREE.Mesh(armGeo, skinMat); rightArm.position.set(0.55, 1.05, 0); player.add(rightArm);

      const legGeo = new THREE.CapsuleGeometry(0.12, 0.5, 6, 10);
      const leftLeg = new THREE.Mesh(legGeo, skinMat); leftLeg.position.set(-0.18, 0.35, 0); player.add(leftLeg);
      const rightLeg = new THREE.Mesh(legGeo, skinMat); rightLeg.position.set(0.18, 0.35, 0); player.add(rightLeg);

      const shoeGeo = new THREE.BoxGeometry(0.22, 0.10, 0.32);
      const leftShoe = new THREE.Mesh(shoeGeo, shoeMat); leftShoe.position.set(-0.18, 0.05, 0.08); player.add(leftShoe);
      const rightShoe = new THREE.Mesh(shoeGeo, shoeMat); rightShoe.position.set(0.18, 0.05, 0.08); player.add(rightShoe);

      player.position.set(0, 0, roomA_Z + 3);

      // Camera controls
      let yaw = Math.PI;
      let pitch = 0.28;
      let distance = 10.5;
      const minDist = 5.0, maxDist = 16.0;
      const minPitch = 0.08, maxPitch = 1.05;

      let draggingL = false;
      let mouseLock = false;
      let lastX = 0, lastY = 0;

      renderer.domElement.addEventListener("mousedown", (e) => {
        if (e.button === 0) { draggingL = true; lastX = e.clientX; lastY = e.clientY; }
        if (e.button === 2) { mouseLock = true; lastX = e.clientX; lastY = e.clientY; showToast("Mouse-lock: ON (hold RMB)"); }
      });
      window.addEventListener("mouseup", (e) => {
        if (e.button === 0) draggingL = false;
        if (e.button === 2) { mouseLock = false; showToast("Mouse-lock: OFF"); }
      });
      window.addEventListener("mousemove", (e) => {
        const active = draggingL || mouseLock;
        if (!active) return;

        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        yaw   -= dx * 0.006;
        pitch -= dy * 0.004;
        pitch = Math.max(minPitch, Math.min(maxPitch, pitch));

        if (mouseLock) player.rotation.y = yaw;
      });
      window.addEventListener("wheel", (e) => {
        distance += e.deltaY * 0.0035;
        distance = Math.max(minDist, Math.min(maxDist, distance));
      }, { passive:true });

      // Camera collision
      const camTarget = new THREE.Vector3();
      const desiredCamPos = new THREE.Vector3();
      const finalCamPos = new THREE.Vector3();
      const raycaster = new THREE.Raycaster();
      const camDir = new THREE.Vector3();
      const camSafety = 0.35;
      const camUpOffset = 1.0;

      function applyCameraCollision(target, desiredPos) {
        camDir.copy(desiredPos).sub(target);
        const dist = camDir.length();
        if (dist < 0.001) return desiredPos;

        camDir.normalize();
        raycaster.set(target, camDir);
        raycaster.far = dist;

        const hits = raycaster.intersectObjects(colliders, false);
        if (hits.length > 0) {
          const hitDist = Math.max(0.7, hits[0].distance - camSafety);
          return finalCamPos.copy(target).addScaledVector(camDir, hitDist);
        }
        return desiredPos;
      }

      // Frames
      const texLoader = new THREE.TextureLoader();
      texLoader.crossOrigin = "anonymous";
      const framePlanes = [];

      function makeFrame(texture, x, y, z, rotY, url) {
        const group = new THREE.Group();
        group.position.set(x, y, z);
        group.rotation.y = rotY;

        const frame = new THREE.Mesh(
          new THREE.BoxGeometry(2.6, 1.7, 0.08),
          new THREE.MeshStandardMaterial({ color: 0x2b1a1f, roughness: 0.7, metalness: 0.1 })
        );
        frame.position.z = 0.02; group.add(frame);

        const matte = new THREE.Mesh(
          new THREE.BoxGeometry(2.35, 1.45, 0.02),
          new THREE.MeshStandardMaterial({ color: 0xf5eff3, roughness: 1.0 })
        );
        matte.position.z = 0.065; group.add(matte);

        const photo = new THREE.Mesh(
          new THREE.PlaneGeometry(2.1, 1.2),
          new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9 })
        );
        photo.position.z = 0.085;
        photo.userData.photoUrl = url;
        framePlanes.push(photo);
        group.add(photo);

        scene.add(group);
      }

      function placeFramesForRoom(zCenter, offset) {
        const frameY = 3.1;
        const backZ  = zCenter - roomD/2 + 0.35;
        const frontZ = zCenter + roomD/2 - 0.35;
        const leftX  = -roomW/2 + 0.35;
        const rightX =  roomW/2 - 0.35;

        const placements = [
          { x:-7, y:frameY, z:backZ,  rotY:0 },
          { x: 0, y:frameY, z:backZ,  rotY:0 },
          { x: 7, y:frameY, z:backZ,  rotY:0 },
          { x:-7, y:frameY, z:frontZ, rotY:Math.PI },
          { x: 0, y:frameY, z:frontZ, rotY:Math.PI },
          { x: 7, y:frameY, z:frontZ, rotY:Math.PI },
          { x:leftX,  y:frameY, z:zCenter-4, rotY: Math.PI/2 },
          { x:leftX,  y:frameY, z:zCenter+4, rotY: Math.PI/2 },
          { x:rightX, y:frameY, z:zCenter-4, rotY:-Math.PI/2 },
          { x:rightX, y:frameY, z:zCenter+4, rotY:-Math.PI/2 },
        ];

        placements.forEach((p, i) => {
          const url = PHOTO_URLS[(offset + i) % PHOTO_URLS.length];
          texLoader.load(
            url,
            (tex) => makeFrame(tex, p.x, p.y, p.z, p.rotY, url),
            undefined,
            () => showToast("Some images blocked (try different direct image URLs)")
          );
        });
      }
      placeFramesForRoom(roomA_Z, 0);
      placeFramesForRoom(roomB_Z, 4);

      // Love wall
      const loveTex = makeLoveTexture();
      const loveWall = new THREE.Mesh(
        new THREE.PlaneGeometry(9.2, 3.4),
        new THREE.MeshStandardMaterial({ map: loveTex, roughness: 0.95 })
      );
      loveWall.position.set(0, 3.05, roomB_Z - roomD/2 + 0.56);
      scene.add(loveWall);

      function nearestFrame(maxDist = 2.9) {
        let best = null, bestD = Infinity;
        const p = new THREE.Vector3(player.position.x, 1.35, player.position.z);
        for (const pl of framePlanes) {
          const wp = new THREE.Vector3();
          pl.getWorldPosition(wp);
          const d = wp.distanceTo(p);
          if (d < bestD && d <= maxDist) { bestD = d; best = pl; }
        }
        return best;
      }

      // Movement (holdable)
      const velocity = new THREE.Vector3();
      const targetVel = new THREE.Vector3();
      const tmpForward = new THREE.Vector3();
      const tmpRight = new THREE.Vector3();
      const wishDir = new THREE.Vector3();

      const WALK_SPEED = 10.5;
      const RUN_SPEED  = 17.0;
      const ACCEL_TAU  = 0.04;
      const BRAKE_TAU  = 0.055;
      const ROT_SMOOTH = 26.0;

      let walkPhase = 0;
      let eLatch = false;
      let rLatch = false;
      let autoRun = false;

      const bounds = {
        xMin: -roomW/2 + 1.2,
        xMax:  roomW/2 - 1.2,
        zMin: roomB_Z - roomD/2 + 1.2,
        zMax: roomA_Z + roomD/2 - 1.2
      };

      camTarget.set(player.position.x, 1.35, player.position.z);
      camera.position.set(camTarget.x, camTarget.y + 6, camTarget.z + 10);
      camera.lookAt(camTarget);
      renderer.render(scene, camera);

      const clock = new THREE.Clock();
      function loop() {
        const dt = Math.min(clock.getDelta(), 0.033);

        // basis from yaw
        tmpForward.set(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        tmpForward.y = 0; tmpForward.normalize();
        tmpRight.copy(tmpForward).cross(new THREE.Vector3(0,1,0)).normalize();

        const w = pressed.has("KeyW");
        const a = pressed.has("KeyA");
        const s = pressed.has("KeyS");
        const d = pressed.has("KeyD");
        const shift = pressed.has("ShiftLeft") || pressed.has("ShiftRight");
        const e = pressed.has("KeyE");
        const r = pressed.has("KeyR");

        if (r && !rLatch) { rLatch = true; autoRun = !autoRun; showToast(autoRun ? "Auto-run: ON âœ…" : "Auto-run: OFF âŽ"); }
        if (!r) rLatch = false;

        if (e && !eLatch && !modal.classList.contains("show")) {
          eLatch = true;
          const f = nearestFrame(2.9);
          if (f && f.userData && f.userData.photoUrl) openModal(f.userData.photoUrl);
          else showToast("Go closer to a frame âœ¨");
        }
        if (!e) eLatch = false;

        wishDir.set(0,0,0);
        if (autoRun) wishDir.add(tmpForward);
        if (w) wishDir.add(tmpForward);
        if (s) wishDir.sub(tmpForward);
        if (d) wishDir.add(tmpRight);
        if (a) wishDir.sub(tmpRight);

        const hasInput = wishDir.lengthSq() > 0 && !modal.classList.contains("show");

        // FOV smooth
        const desiredFov = (shift && hasInput) ? runFov : baseFov;
        camera.fov = camera.fov + (desiredFov - camera.fov) * (1 - Math.exp(-10 * dt));
        camera.updateProjectionMatrix();

        if (hasInput) {
          wishDir.normalize();
          const topSpeed = shift ? RUN_SPEED : WALK_SPEED;
          targetVel.copy(wishDir).multiplyScalar(topSpeed);
          velocity.lerp(targetVel, dampAlpha(dt, ACCEL_TAU));

          // Face movement direction unless RMB mouse-lock
          if (!mouseLock) {
            const targetYaw = Math.atan2(wishDir.x, wishDir.z);
            player.rotation.y = lerpAngle(player.rotation.y, targetYaw, 1 - Math.exp(-ROT_SMOOTH * dt));
          }

          const speedNow = Math.hypot(velocity.x, velocity.z);
          walkPhase += dt * (speedNow * 1.1);
        } else {
          targetVel.set(0,0,0);
          velocity.lerp(targetVel, dampAlpha(dt, BRAKE_TAU));
        }

        // subtle bob
        const speedFactor = Math.min(1, Math.hypot(velocity.x, velocity.z) / RUN_SPEED);
        player.position.y = (Math.abs(Math.sin(walkPhase)) * 0.03) * speedFactor;

        if (!modal.classList.contains("show")) {
          player.position.x += velocity.x * dt;
          player.position.z += velocity.z * dt;
        }

        player.position.x = THREE.MathUtils.clamp(player.position.x, bounds.xMin, bounds.xMax);
        player.position.z = THREE.MathUtils.clamp(player.position.z, bounds.zMin, bounds.zMax);

        // camera follow + collision
        camTarget.set(player.position.x, 1.35 + player.position.y, player.position.z);

        const cosP = Math.cos(pitch), sinP = Math.sin(pitch);
        desiredCamPos.set(
          camTarget.x + Math.sin(yaw) * (distance * cosP),
          camTarget.y + (distance * sinP) + camUpOffset,
          camTarget.z + Math.cos(yaw) * (distance * cosP)
        );

        const collided = applyCameraCollision(camTarget, desiredCamPos);
        camera.position.lerp(collided, 1 - Math.exp(-10.5 * dt));
        camera.lookAt(camTarget);

        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);

      window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      showToast("Tip: Hold RMB for Roblox mouse-lock âœ¨");
    }
  </script>
</body>
</html>
