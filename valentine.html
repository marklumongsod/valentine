<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Museum Walk â€” Mobile Ready</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0b10; touch-action: none; }
    canvas { display:block; outline:none; touch-action:none; }

    .hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      color: rgba(255,255,255,.92);
      font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      padding: 10px 10px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      max-width: 92vw;
    }
    .hud b { font-weight: 900; }
    .hint { opacity:.85; margin-top:6px; }

    .overlay {
      position: fixed; inset: 0; z-index: 50;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(900px 460px at 50% 40%, rgba(255,255,255,.08), rgba(0,0,0,.82));
      color: rgba(255,255,255,.95);
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      text-align:center;
      padding: 18px;
    }
    .overlayCard{
      width:min(760px, 92vw);
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding: 16px 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 24px 70px rgba(0,0,0,.35);
    }
    .overlayCard h1{ margin:0 0 8px; font-size:22px; }
    .overlayCard p{ margin: 8px 0; opacity:.92; }
    .startBtn{
      margin-top: 14px;
      border:none;
      padding: 12px 16px;
      border-radius: 14px;
      background: rgba(255,59,107,.95);
      color: white;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 14px 34px rgba(255,59,107,.22);
      width: 100%;
      max-width: 320px;
    }

    .modal {
      position: fixed; inset: 0; z-index: 60;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.75);
      padding: 14px;
    }
    .modal.show{ display:flex; }
    .modalCard{
      width:min(980px, 96vw);
      background: rgba(10,10,16,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      overflow:hidden;
      box-shadow: 0 30px 90px rgba(0,0,0,.45);
    }
    .modalTop{
      display:flex; align-items:center; justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      color: rgba(255,255,255,.92);
      font: 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .modalTop b{ font-weight: 900; }
    .closeBtn{
      border:none; cursor:pointer;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      font-weight: 900;
    }
    .modalImg{
      width:100%;
      height: min(70vh, 680px);
      object-fit: cover;
      display:block;
    }

    .toast {
      position: fixed; right: 12px; bottom: 12px; z-index: 70;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 14px;
      backdrop-filter: blur(10px);
      font: 12px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity .2s ease, transform .2s ease;
      pointer-events: none;
      white-space: nowrap;
    }
    .toast.show { opacity: 1; transform: translateY(0); }

    /* Mobile touch controls */
    .touchUI {
      position: fixed; inset: 0;
      pointer-events: none;
      z-index: 25;
    }
    .pad {
      position: absolute;
      bottom: max(14px, env(safe-area-inset-bottom));
      width: 42vw;
      height: 32vh;
      max-width: 260px;
      max-height: 220px;
      border-radius: 18px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      pointer-events: auto;
      touch-action: none;
      user-select: none;
    }
    .pad.left { left: max(14px, env(safe-area-inset-left)); }
    .pad.right { right: max(14px, env(safe-area-inset-right)); }
    .padLabel {
      position:absolute; top:10px; left:12px;
      color: rgba(255,255,255,.75);
      font: 12px system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .stick {
      position:absolute;
      left: 50%; top: 50%;
      width: 64px; height: 64px;
      margin-left:-32px; margin-top:-32px;
      border-radius: 50%;
      background: rgba(255,255,255,.14);
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      transform: translate(0,0);
    }
    .btnBar {
      position: fixed;
      top: max(12px, env(safe-area-inset-top));
      right: max(12px, env(safe-area-inset-right));
      z-index: 26;
      display:flex;
      gap: 10px;
    }
    .uiBtn {
      pointer-events:auto;
      border:none;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.92);
      font-weight: 900;
      font: 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      backdrop-filter: blur(10px);
    }
    .uiBtn.primary {
      background: rgba(255,59,107,.92);
      border-color: rgba(255,59,107,.35);
    }
    @media (hover:hover) and (pointer:fine){
      /* On desktop, make touch pads smaller / less visible */
      .pad { opacity: .35; }
    }
  </style>
</head>
<body>
  <div class="hud">
    <div><b>Museum Walk</b> â€” mobile ready</div>
    <div class="hint">
      Mobile: <b>Left pad</b> move â€¢ <b>Right pad</b> look â€¢ <b>View</b> near frame<br/>
      PC: hold <b>WASD</b> â€¢ <b>Shift</b> sprint â€¢ <b>R</b> autorun â€¢ <b>E</b> view
    </div>
  </div>

  <div class="btnBar">
    <button class="uiBtn primary" id="viewBtn">View Frame</button>
    <button class="uiBtn" id="runBtn">Auto-run</button>
  </div>

  <div class="touchUI">
    <div class="pad left" id="movePad">
      <div class="padLabel">MOVE</div>
      <div class="stick" id="moveStick"></div>
    </div>
    <div class="pad right" id="lookPad">
      <div class="padLabel">LOOK</div>
      <div class="stick" id="lookStick"></div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="overlayCard">
      <h1>Tap START to enter the museum</h1>
      <p>iPhone/Android friendly âœ…</p>
      <button class="startBtn" id="startBtn">START âœ¨</button>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="modalCard">
      <div class="modalTop">
        <div><b>Gallery View</b></div>
        <button class="closeBtn" id="closeBtn">Close âœ•</button>
      </div>
      <img class="modalImg" id="modalImg" alt="Selected frame" />
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="errorBox" id="errorBox"></div>

  <!-- CDN (NON-MODULE) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>

  <script>
    // Replace with YOUR real photo links (public direct image URLs)
    const PHOTO_URLS = [
      "https://images.unsplash.com/photo-1518199266791-5375a83190b7?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1518621736915-f3b1c41bfd00?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1519681393784-d120267933ba?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1517486808906-6ca8b3f04846?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1529626455594-4ff0802cfb7e?w=1400&h=900&fit=crop",
      "https://images.unsplash.com/photo-1524504388940-b1c1722653e1?w=1400&h=900&fit=crop",
    ];

    const LOVE_TITLE = "HAPPY VALENTINEâ€™S, LOVE ðŸ’–";
    const LOVE_LINES = [
      "Ikaw ang paborito kong notificationâ€¦",
      "kahit naka-silent ang phone.",
      "",
      "Mas mahal kita kaysa sa",
      "â€œgit pushâ€ na walang conflicts ðŸ˜­",
      "",
      "P.S. Kung may lag, ikaw pa rin ang love ko ðŸ’˜"
    ];

    const overlay = document.getElementById("overlay");
    const startBtn = document.getElementById("startBtn");
    const modal = document.getElementById("modal");
    const modalImg = document.getElementById("modalImg");
    const closeBtn = document.getElementById("closeBtn");
    const toast = document.getElementById("toast");

    const viewBtn = document.getElementById("viewBtn");
    const runBtn = document.getElementById("runBtn");

    function showToast(msg) {
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.classList.remove("show"), 1400);
    }

    function openModal(url){
      modalImg.src = url;
      modal.classList.add("show");
    }
    function closeModal(){
      modal.classList.remove("show");
      modalImg.src = "";
    }
    closeBtn.addEventListener("click", closeModal);
    modal.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });

    // Keyboard input (desktop)
    const pressed = new Set();
    function armKeyboard(){
      window.addEventListener("keydown", (e) => {
        if (["KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","KeyE","KeyR"].includes(e.code)) e.preventDefault();
        pressed.add(e.code);
      }, { capture:true, passive:false });
      window.addEventListener("keyup", (e) => {
        if (["KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","KeyE","KeyR"].includes(e.code)) e.preventDefault();
        pressed.delete(e.code);
      }, { capture:true, passive:false });
      window.addEventListener("blur", () => pressed.clear());
      document.addEventListener("visibilitychange", () => { if (document.hidden) pressed.clear(); });
    }

    // Touch joystick helpers
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function vecLen(x,y){ return Math.hypot(x,y); }

    function createPad(padEl, stickEl){
      let active = false;
      let id = null;
      let cx = 0, cy = 0;
      let dx = 0, dy = 0;

      function reset(){
        dx = dy = 0;
        stickEl.style.transform = "translate(0px,0px)";
      }

      function onDown(e){
        active = true;
        const t = (e.changedTouches ? e.changedTouches[0] : e);
        id = t.identifier ?? "mouse";
        const r = padEl.getBoundingClientRect();
        cx = r.left + r.width/2;
        cy = r.top + r.height/2;
        onMove(e);
      }

      function onMove(e){
        if(!active) return;
        let t = null;
        if(e.changedTouches){
          for(const tt of e.changedTouches){
            if((tt.identifier ?? "mouse") === id){ t = tt; break; }
          }
          if(!t) return;
        } else t = e;

        const r = padEl.getBoundingClientRect();
        const maxR = Math.min(r.width, r.height) * 0.30; // stick range
        const x = t.clientX - cx;
        const y = t.clientY - cy;

        const L = vecLen(x,y);
        const nx = (L > maxR) ? (x / L) * maxR : x;
        const ny = (L > maxR) ? (y / L) * maxR : y;

        dx = clamp(nx / maxR, -1, 1);
        dy = clamp(ny / maxR, -1, 1);

        stickEl.style.transform = `translate(${nx}px,${ny}px)`;
      }

      function onUp(e){
        if(!active) return;
        if(e.changedTouches){
          for(const tt of e.changedTouches){
            if((tt.identifier ?? "mouse") === id){
              active = false; id = null; reset();
              return;
            }
          }
        } else {
          active = false; id = null; reset();
        }
      }

      padEl.addEventListener("touchstart", (e)=>{ e.preventDefault(); onDown(e); }, {passive:false});
      padEl.addEventListener("touchmove",  (e)=>{ e.preventDefault(); onMove(e); }, {passive:false});
      padEl.addEventListener("touchend",   (e)=>{ e.preventDefault(); onUp(e); }, {passive:false});
      padEl.addEventListener("touchcancel",(e)=>{ e.preventDefault(); onUp(e); }, {passive:false});

      // mouse fallback
      padEl.addEventListener("mousedown", (e)=>{ e.preventDefault(); onDown(e); }, {passive:false});
      window.addEventListener("mousemove", (e)=>{ onMove(e); }, {passive:true});
      window.addEventListener("mouseup", (e)=>{ onUp(e); }, {passive:true});

      return { get dx(){return dx;}, get dy(){return dy;} };
    }

    // Angle helpers
    function wrapAngleRad(x){
      const pi2 = Math.PI * 2;
      x = (x + Math.PI) % pi2;
      if (x < 0) x += pi2;
      return x - Math.PI;
    }
    function lerpAngle(a,b,t){
      const diff = wrapAngleRad(b - a);
      return a + diff * t;
    }
    function dampAlpha(dt, tau){ return 1 - Math.exp(-dt / Math.max(0.0001, tau)); }

    let started = false;

    startBtn.addEventListener("click", startFlow);
    startBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); startFlow(); }, {passive:false});

    function startFlow(){
      if(started) return;
      started = true;

      if(!window.THREE){
        overlay.style.display = "none";
        alert("Three.js failed to load. Check internet / CDN blocked.");
        return;
      }

      overlay.style.display = "none";
      armKeyboard();
      initAndRun();
    }

    function makeLoveTexture(){
      const c = document.createElement("canvas");
      c.width = 1400; c.height = 520;
      const ctx = c.getContext("2d");

      const g = ctx.createLinearGradient(0,0,c.width,c.height);
      g.addColorStop(0, "#ffe1ec");
      g.addColorStop(1, "#ffd0de");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,c.width,c.height);

      ctx.strokeStyle = "rgba(255,59,107,0.75)";
      ctx.lineWidth = 16;
      ctx.strokeRect(16,16,c.width-32,c.height-32);

      ctx.globalAlpha = 0.12;
      ctx.font = "80px system-ui";
      for(let i=0;i<14;i++) ctx.fillText("ðŸ’–", 80 + i*90, 110 + (i%2)*70);
      ctx.globalAlpha = 1;

      ctx.fillStyle = "#ff2f67";
      ctx.font = "900 64px system-ui";
      ctx.textAlign = "center";
      ctx.fillText(LOVE_TITLE, c.width/2, 120);

      ctx.fillStyle = "#2b1a1f";
      ctx.font = "600 44px system-ui";
      let y = 200;
      for(const line of LOVE_LINES){ ctx.fillText(line, c.width/2, y); y += 54; }

      return new THREE.CanvasTexture(c);
    }

    function initAndRun(){
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0b0b10, 22, 90);

      const baseFov = 65, runFov = 74;
      const camera = new THREE.PerspectiveCamera(baseFov, innerWidth/innerHeight, 0.1, 220);

      const renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setClearColor(0x0b0b10, 1);
      document.body.appendChild(renderer.domElement);
      renderer.domElement.oncontextmenu = (e)=>e.preventDefault();

      scene.add(new THREE.HemisphereLight(0xffffff, 0x1b1b2a, 0.9));
      const key = new THREE.DirectionalLight(0xffffff, 0.9);
      key.position.set(10,16,10);
      scene.add(key);

      function addSpot(x,z){
        const s = new THREE.SpotLight(0xffffff, 1.0, 28, Math.PI*0.22, 0.55, 1.2);
        s.position.set(x, 7.6, z);
        s.target.position.set(x, 2.0, z);
        scene.add(s); scene.add(s.target);
      }

      // Museum geometry
      const roomW=28, roomD=16, wallH=6, wallT=0.4;
      const roomA_Z=0;
      const hallW=8, hallD=10;
      const hall_Z=-(roomD/2 + hallD/2);
      const roomB_Z=-(roomD + hallD);

      const colliders = [];

      function floor(w,d,z){
        const f = new THREE.Mesh(
          new THREE.PlaneGeometry(w,d),
          new THREE.MeshStandardMaterial({ color:0x1a1a22, roughness:0.88, metalness:0.05 })
        );
        f.rotation.x = -Math.PI/2;
        f.position.z = z;
        scene.add(f);
      }
      floor(roomW, roomD, roomA_Z);
      floor(hallW, hallD, hall_Z);
      floor(roomW, roomD, roomB_Z);

      const wallMat = new THREE.MeshStandardMaterial({ color:0xf3eef2, roughness:0.96 });

      function wall(w,h,d,x,y,z){
        const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
        m.position.set(x,y,z);
        scene.add(m);
        colliders.push(m);
      }
      function ceil(w,d,z){
        const c = new THREE.Mesh(
          new THREE.PlaneGeometry(w,d),
          new THREE.MeshStandardMaterial({ color:0xf7f1f6, roughness:1.0 })
        );
        c.position.set(0, wallH, z);
        c.rotation.x = Math.PI/2;
        scene.add(c);
      }

      const doorW = hallW;
      const sideW = (roomW - doorW)/2;

      // Room A (door at back)
      wall(roomW, wallH, wallT, 0, wallH/2, roomA_Z + roomD/2);
      wall(wallT, wallH, roomD, -roomW/2, wallH/2, roomA_Z);
      wall(wallT, wallH, roomD,  roomW/2, wallH/2, roomA_Z);
      wall(sideW, wallH, wallT, -(doorW/2 + sideW/2), wallH/2, roomA_Z - roomD/2);
      wall(sideW, wallH, wallT, +(doorW/2 + sideW/2), wallH/2, roomA_Z - roomD/2);
      ceil(roomW, roomD, roomA_Z);

      // Hall
      wall(hallW, wallH, wallT, 0, wallH/2, hall_Z + hallD/2);
      wall(hallW, wallH, wallT, 0, wallH/2, hall_Z - hallD/2);
      wall(wallT, wallH, hallD, -hallW/2, wallH/2, hall_Z);
      wall(wallT, wallH, hallD,  hallW/2, wallH/2, hall_Z);
      ceil(hallW, hallD, hall_Z);

      // Room B (door at front)
      wall(roomW, wallH, wallT, 0, wallH/2, roomB_Z - roomD/2);
      wall(wallT, wallH, roomD, -roomW/2, wallH/2, roomB_Z);
      wall(wallT, wallH, roomD,  roomW/2, wallH/2, roomB_Z);
      wall(sideW, wallH, wallT, -(doorW/2 + sideW/2), wallH/2, roomB_Z + roomD/2);
      wall(sideW, wallH, wallT, +(doorW/2 + sideW/2), wallH/2, roomB_Z + roomD/2);
      ceil(roomW, roomD, roomB_Z);

      // Spots
      addSpot(-7, roomA_Z - 4); addSpot(0, roomA_Z - 4); addSpot(7, roomA_Z - 4);
      addSpot(-7, roomA_Z + 4); addSpot(0, roomA_Z + 4); addSpot(7, roomA_Z + 4);
      addSpot(0, hall_Z);
      addSpot(-7, roomB_Z - 4); addSpot(0, roomB_Z - 4); addSpot(7, roomB_Z - 4);
      addSpot(-7, roomB_Z + 4); addSpot(0, roomB_Z + 4); addSpot(7, roomB_Z + 4);

      // Character (girl)
      const player = new THREE.Group();
      scene.add(player);

      const skin  = new THREE.MeshStandardMaterial({ color:0xffd4c2, roughness:0.85 });
      const hair  = new THREE.MeshStandardMaterial({ color:0x24140f, roughness:0.9 });
      const dress = new THREE.MeshStandardMaterial({ color:0xff3b6b, roughness:0.7 });
      const shoe  = new THREE.MeshStandardMaterial({ color:0x22222a, roughness:0.6 });

      const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 24, 24), skin);
      head.position.set(0, 1.55, 0); player.add(head);

      const hairCap = new THREE.Mesh(new THREE.SphereGeometry(0.37, 24, 24, 0, Math.PI*2, 0, Math.PI*0.65), hair);
      hairCap.position.copy(head.position); hairCap.position.y += 0.05; player.add(hairCap);

      const pony = new THREE.Mesh(new THREE.SphereGeometry(0.20, 20, 20), hair);
      pony.position.set(0.22, 1.42, -0.18); player.add(pony);

      const body = new THREE.Mesh(new THREE.CylinderGeometry(0.42, 0.55, 0.9, 18), dress);
      body.position.set(0, 0.95, 0); player.add(body);

      const armGeo = new THREE.CapsuleGeometry(0.11, 0.42, 6, 10);
      const la = new THREE.Mesh(armGeo, skin); la.position.set(-0.55, 1.05, 0); player.add(la);
      const ra = new THREE.Mesh(armGeo, skin); ra.position.set(0.55, 1.05, 0); player.add(ra);

      const legGeo = new THREE.CapsuleGeometry(0.12, 0.5, 6, 10);
      const ll = new THREE.Mesh(legGeo, skin); ll.position.set(-0.18, 0.35, 0); player.add(ll);
      const rl = new THREE.Mesh(legGeo, skin); rl.position.set(0.18, 0.35, 0); player.add(rl);

      const shoeGeo = new THREE.BoxGeometry(0.22, 0.10, 0.32);
      const ls = new THREE.Mesh(shoeGeo, shoe); ls.position.set(-0.18, 0.05, 0.08); player.add(ls);
      const rs = new THREE.Mesh(shoeGeo, shoe); rs.position.set(0.18, 0.05, 0.08); player.add(rs);

      player.position.set(0, 0, roomA_Z + 3);

      // Love wall
      const loveTex = makeLoveTexture();
      const loveWall = new THREE.Mesh(
        new THREE.PlaneGeometry(9.2, 3.4),
        new THREE.MeshStandardMaterial({ map: loveTex, roughness: 0.95 })
      );
      loveWall.position.set(0, 3.05, roomB_Z - roomD/2 + 0.56);
      scene.add(loveWall);

      // Frames
      const loader = new THREE.TextureLoader();
      loader.crossOrigin = "anonymous";
      const framePlanes = [];

      function makeFrame(texture, x,y,z, rotY, url){
        const g = new THREE.Group();
        g.position.set(x,y,z);
        g.rotation.y = rotY;

        const frame = new THREE.Mesh(
          new THREE.BoxGeometry(2.6,1.7,0.08),
          new THREE.MeshStandardMaterial({ color:0x2b1a1f, roughness:0.7, metalness:0.1 })
        );
        frame.position.z = 0.02; g.add(frame);

        const matte = new THREE.Mesh(
          new THREE.BoxGeometry(2.35,1.45,0.02),
          new THREE.MeshStandardMaterial({ color:0xf5eff3, roughness:1.0 })
        );
        matte.position.z = 0.065; g.add(matte);

        const photo = new THREE.Mesh(
          new THREE.PlaneGeometry(2.1,1.2),
          new THREE.MeshStandardMaterial({ map: texture, roughness:0.9 })
        );
        photo.position.z = 0.085;
        photo.userData.photoUrl = url;
        framePlanes.push(photo);
        g.add(photo);

        scene.add(g);
      }

      function placeFrames(zCenter, offset){
        const frameY=3.1;
        const backZ=zCenter-roomD/2+0.35, frontZ=zCenter+roomD/2-0.35;
        const leftX=-roomW/2+0.35, rightX=roomW/2-0.35;

        const ps = [
          {x:-7,y:frameY,z:backZ, rotY:0},
          {x: 0,y:frameY,z:backZ, rotY:0},
          {x: 7,y:frameY,z:backZ, rotY:0},
          {x:-7,y:frameY,z:frontZ,rotY:Math.PI},
          {x: 0,y:frameY,z:frontZ,rotY:Math.PI},
          {x: 7,y:frameY,z:frontZ,rotY:Math.PI},
          {x:-roomW/2+0.35, y:frameY,z:zCenter-4, rotY: Math.PI/2},
          {x:-roomW/2+0.35, y:frameY,z:zCenter+4, rotY: Math.PI/2},
          {x: roomW/2-0.35, y:frameY,z:zCenter-4, rotY:-Math.PI/2},
          {x: roomW/2-0.35, y:frameY,z:zCenter+4, rotY:-Math.PI/2},
        ];

        ps.forEach((p,i)=>{
          const url = PHOTO_URLS[(offset+i)%PHOTO_URLS.length];
          loader.load(url, (tex)=>makeFrame(tex,p.x,p.y,p.z,p.rotY,url));
        });
      }
      placeFrames(roomA_Z, 0);
      placeFrames(roomB_Z, 4);

      function nearestFrame(maxDist=2.9){
        let best=null, bestD=Infinity;
        const p = new THREE.Vector3(player.position.x, 1.35, player.position.z);
        for(const pl of framePlanes){
          const wp=new THREE.Vector3(); pl.getWorldPosition(wp);
          const d=wp.distanceTo(p);
          if(d < bestD && d <= maxDist){ bestD=d; best=pl; }
        }
        return best;
      }

      // Touch pads
      const movePad = createPad(
        document.getElementById("movePad"),
        document.getElementById("moveStick")
      );
      const lookPad = createPad(
        document.getElementById("lookPad"),
        document.getElementById("lookStick")
      );

      // Buttons
      let autoRun = false;
      runBtn.addEventListener("click", ()=>{ autoRun=!autoRun; runBtn.textContent = autoRun ? "Auto-run âœ“" : "Auto-run"; showToast(autoRun ? "Auto-run ON âœ…" : "Auto-run OFF âŽ"); });
      viewBtn.addEventListener("click", ()=> {
        if(modal.classList.contains("show")) return;
        const f = nearestFrame(2.9);
        if(f?.userData?.photoUrl) openModal(f.userData.photoUrl);
        else showToast("Lapitan mo yung frame âœ¨");
      });

      // Camera orbit
      let yaw = Math.PI, pitch = 0.28, dist = 10.5;
      const minDist=5, maxDist=16, minPitch=0.08, maxPitch=1.05;

      // Right pad = look (touch)
      // dx = left/right, dy = up/down
      const LOOK_SENS = 2.4; // mobile feel
      const ZOOM_SENS = 0.02;

      // Pinch zoom (simple)
      let pinchActive=false, pinchStart=0, pinchDist=0;
      function touchDist(t1,t2){
        const dx=t1.clientX-t2.clientX, dy=t1.clientY-t2.clientY;
        return Math.hypot(dx,dy);
      }
      window.addEventListener("touchstart",(e)=>{
        if(e.touches && e.touches.length===2){
          pinchActive=true;
          pinchDist = touchDist(e.touches[0], e.touches[1]);
          pinchStart = dist;
        }
      }, {passive:true});
      window.addEventListener("touchmove",(e)=>{
        if(pinchActive && e.touches && e.touches.length===2){
          const d0 = touchDist(e.touches[0], e.touches[1]);
          const delta = (pinchDist - d0) * ZOOM_SENS;
          dist = clamp(pinchStart + delta, minDist, maxDist);
        }
      }, {passive:true});
      window.addEventListener("touchend",(e)=>{
        if(!e.touches || e.touches.length<2) pinchActive=false;
      }, {passive:true});

      // Desktop mouse drag (optional)
      let draggingL=false, lastX=0, lastY=0;
      renderer.domElement.addEventListener("mousedown",(e)=>{
        if(e.button===0){ draggingL=true; lastX=e.clientX; lastY=e.clientY; }
      });
      window.addEventListener("mouseup",()=> draggingL=false);
      window.addEventListener("mousemove",(e)=>{
        if(!draggingL) return;
        const dx=e.clientX-lastX, dy=e.clientY-lastY;
        lastX=e.clientX; lastY=e.clientY;
        yaw -= dx*0.006;
        pitch -= dy*0.004;
        pitch = clamp(pitch, minPitch, maxPitch);
      });
      window.addEventListener("wheel",(e)=>{
        dist += e.deltaY*0.0035;
        dist = clamp(dist, minDist, maxDist);
      }, {passive:true});

      // Camera collision
      const camTarget=new THREE.Vector3();
      const desiredCam=new THREE.Vector3();
      const finalCam=new THREE.Vector3();
      const raycaster=new THREE.Raycaster();
      const camDir=new THREE.Vector3();
      const camSafety=0.35;
      const camUpOffset=1.0;

      function applyCamCollision(target, desiredPos){
        camDir.copy(desiredPos).sub(target);
        const d = camDir.length();
        if(d < 0.001) return desiredPos;
        camDir.normalize();
        raycaster.set(target, camDir);
        raycaster.far = d;
        const hits = raycaster.intersectObjects(colliders,false);
        if(hits.length){
          const hitDist = Math.max(0.7, hits[0].distance - camSafety);
          return finalCam.copy(target).addScaledVector(camDir, hitDist);
        }
        return desiredPos;
      }

      // Movement
      const vel = new THREE.Vector3();
      const targetVel = new THREE.Vector3();
      const tmpF = new THREE.Vector3();
      const tmpR = new THREE.Vector3();
      const wish = new THREE.Vector3();

      const WALK=9.8, RUN=15.8, ACC=0.05, BRK=0.06, ROT=22.0;
      let walkPhase=0;

      const bounds = {
        xMin: -roomW/2 + 1.2,
        xMax:  roomW/2 - 1.2,
        zMin: roomB_Z - roomD/2 + 1.2,
        zMax: roomA_Z + roomD/2 - 1.2
      };

      camTarget.set(player.position.x, 1.35, player.position.z);
      camera.position.set(camTarget.x, camTarget.y + 6, camTarget.z + 10);
      camera.lookAt(camTarget);
      renderer.render(scene, camera);

      const clock = new THREE.Clock();
      function loop(){
        const dt = Math.min(clock.getDelta(), 0.033);

        // Right pad look
        // (stick values -1..1; multiply by dt for smooth)
        yaw   -= lookPad.dx * LOOK_SENS * dt;
        pitch -= lookPad.dy * (LOOK_SENS * 0.8) * dt;
        pitch = clamp(pitch, minPitch, maxPitch);

        // basis from yaw
        tmpF.set(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        tmpF.y=0; tmpF.normalize();
        tmpR.copy(tmpF).cross(new THREE.Vector3(0,1,0)).normalize();

        // Combine keyboard + left pad
        const kw = pressed.has("KeyW");
        const ka = pressed.has("KeyA");
        const ks = pressed.has("KeyS");
        const kd = pressed.has("KeyD");
        const shift = pressed.has("ShiftLeft") || pressed.has("ShiftRight");
        const kAuto = pressed.has("KeyR");
        const kView = pressed.has("KeyE");

        // Autorun toggle via keyboard
        if(kAuto && !loop._rLatch){ loop._rLatch=true; autoRun=!autoRun; runBtn.textContent = autoRun ? "Auto-run âœ“" : "Auto-run"; showToast(autoRun ? "Auto-run ON âœ…" : "Auto-run OFF âŽ"); }
        if(!kAuto) loop._rLatch=false;

        // View via keyboard
        if(kView && !loop._eLatch && !modal.classList.contains("show")){
          loop._eLatch=true;
          const f = nearestFrame(2.9);
          if(f?.userData?.photoUrl) openModal(f.userData.photoUrl);
          else showToast("Go closer to a frame âœ¨");
        }
        if(!kView) loop._eLatch=false;

        wish.set(0,0,0);

        // mobile pad (dy up = negative, so invert)
        const padForward = -movePad.dy;
        const padRight = movePad.dx;

        // apply pad
        wish.addScaledVector(tmpF, padForward);
        wish.addScaledVector(tmpR, padRight);

        // apply keyboard
        if(autoRun) wish.add(tmpF);
        if(kw) wish.add(tmpF);
        if(ks) wish.sub(tmpF);
        if(kd) wish.add(tmpR);
        if(ka) wish.sub(tmpR);

        const hasInput = wish.lengthSq()>0 && !modal.classList.contains("show");

        const desiredFov = ((shift) && hasInput) ? runFov : baseFov;
        camera.fov = camera.fov + (desiredFov - camera.fov) * (1 - Math.exp(-10*dt));
        camera.updateProjectionMatrix();

        const sprint = shift; // desktop sprint
        const top = (sprint && hasInput) ? RUN : WALK;

        if(hasInput){
          wish.normalize();
          targetVel.copy(wish).multiplyScalar(top);
          vel.lerp(targetVel, dampAlpha(dt, ACC));

          // Face move direction (mobile/desktop)
          const targetYaw = Math.atan2(wish.x, wish.z);
          player.rotation.y = lerpAngle(player.rotation.y, targetYaw, 1 - Math.exp(-ROT*dt));

          const sp = Math.hypot(vel.x, vel.z);
          walkPhase += dt*(sp*1.1);
        } else {
          targetVel.set(0,0,0);
          vel.lerp(targetVel, dampAlpha(dt, BRK));
        }

        const speedFactor = Math.min(1, Math.hypot(vel.x, vel.z)/RUN);
        player.position.y = (Math.abs(Math.sin(walkPhase))*0.03)*speedFactor;

        if(!modal.classList.contains("show")){
          player.position.x += vel.x*dt;
          player.position.z += vel.z*dt;
        }

        player.position.x = THREE.MathUtils.clamp(player.position.x, bounds.xMin, bounds.xMax);
        player.position.z = THREE.MathUtils.clamp(player.position.z, bounds.zMin, bounds.zMax);

        camTarget.set(player.position.x, 1.35 + player.position.y, player.position.z);

        const cosP=Math.cos(pitch), sinP=Math.sin(pitch);
        desiredCam.set(
          camTarget.x + Math.sin(yaw)*(dist*cosP),
          camTarget.y + (dist*sinP) + camUpOffset,
          camTarget.z + Math.cos(yaw)*(dist*cosP)
        );

        const camPos = applyCamCollision(camTarget, desiredCam);
        camera.position.lerp(camPos, 1 - Math.exp(-10.5*dt));
        camera.lookAt(camTarget);

        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      window.addEventListener("resize", ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      showToast("Mobile: left pad move, right pad look âœ¨");
    }
  </script>
</body>
</html>
